#!/usr/bin/ruby

require 'optparse'
require 'thread'
require 'tempfile'

require 'yaml'
Thread.abort_on_exception = true

GNUPG = "/usr/bin/gpg"

$program_name = File.basename($0, '.*')

$editor = ENV['EDITOR']
if $editor == nil
  %w{/usr/bin/sensible-editor /usr/bin/editor /usr/bin/vi}.each do |editor|
    if FileTest.executable?(editor)
      $editor = editor
      break
    end
  end
end

class GnuPG
  @@my_keys = nil

  def GnuPG.readwrite3(intxt, infd, stdoutfd, stderrfd, statusfd)
    outtxt, stderrtxt, statustxt = ''
    thread_in = Thread.new {
      infd.print intxt
      infd.close
    }
    thread_out = Thread.new {
      outtxt = stdoutfd.read
      stdoutfd.close
    }
    thread_err = Thread.new {
      errtxt = stderrfd.read
      stderrfd.close
    }
    thread_status = Thread.new {
      statustxt = statusfd.read
      statusfd.close
    } if (statusfd)

    thread_in.join
    thread_out.join
    thread_err.join
    thread_status.join if thread_status

    return outtxt, stderrtxt, statustxt
  end

  def GnuPG.gpgcall(intxt, args, require_success = false)
    inR, inW = IO.pipe
    outR, outW = IO.pipe
    errR, errW = IO.pipe
    statR, statW = IO.pipe

    pid = Kernel.fork do
      inW.close
      outR.close
      errR.close
      statR.close
      STDIN.reopen(inR)
      STDOUT.reopen(outW)
      STDERR.reopen(errW)
      exec(GNUPG, "--status-fd=#{statW.fileno}",  *args)
      raise ("Calling gnupg failed")
    end
    inR.close
    outW.close
    errW.close
    statW.close
    (outtxt, stderrtxt, statustxt) = readwrite3(intxt, inW, outR, errR, statR);
    wpid, status = Process.waitpid2 pid
    throw "Unexpected pid: #{pid} vs #{wpid}" unless pid == wpid
    throw "Process has not exited!?" unless status.exited?
    throw "gpg call did not exit sucessfully" if (require_success and status.exitstatus != 0)
    return outtxt, stderrtxt, statustxt, status.exitstatus
  end

  def GnuPG.init_keys()
    return if @@my_keys
    (outtxt, stderrtxt, statustxt) = GnuPG.gpgcall('', %w{--fast-list-mode --with-colons --with-fingerprint --list-secret-keys}, true)
    @@my_keys = []
    @@my_fprs = []
    outtxt.split("\n").each do |line|
      parts = line.split(':')
      if (parts[0] == "ssb" or parts[0] == "sec")
        @@my_keys.push parts[4]
      elsif (parts[0] == "fpr")
        @@my_fprs.push parts[9]
      end
    end
  end
  def GnuPG.get_my_keys()
    init_keys
    @@my_keys
  end
  def GnuPG.get_my_fprs()
    init_keys
    @@my_fprs
  end
end

def read_input(query, default_yes=true)
  if default_yes
    append = '[Y/n]'
  else
    append = '[y/N]'
  end

  while true
    print "#{query} #{append} "
    i = STDIN.readline.chomp.downcase
    if i==""
      return default_yes
    elsif i=="y"
      return true
    elsif i=="n"
      return false
    end
  end
end

class GroupConfig
  def initialize
    parse_file
    expand_groups
  end

  def parse_file
    begin
      f = File.open('.users')
    rescue Exception => e
      STDERR.puts e
      exit(1)
    end

    @users = {}
    @groups = {}

    lno = 0
    f.readlines.each do |line|
      lno = lno+1
      next if line =~ /^$/
      next if line =~ /^#/
      if (m = /^([a-zA-Z0-9-]+)\s*=\s*([0-9A-Fa-f]{40})\s*$/.match line)
        user = m[1]
        fpr = m[2]
        if @users.has_key?(user)
          STDERR.puts "User #{user} redefined at line #{lno}!"
          exit(1)
        end
        @users[user] = fpr
      elsif (m = /^(@[a-zA-Z0-9-]+)\s*=\s*(.*)$/.match line)
        group = m[1]
        members = m[2].strip
        if @groups.has_key?(group)
          STDERR.puts "Group #{group} redefined at line #{lno}!"
          exit(1)
        end
        members = members.split(/[\t ,]+/)
        @groups[group] = { "members" => members }
      end
    end
  end

  def is_group(name)
    return (name =~ /^@/)
  end
  def check_exists(x, whence, fatal=true)
    ok=true
    if is_group(x)
      ok=false unless (@groups.has_key?(x))
    else
      ok=false unless @users.has_key?(x)
    end
    unless ok
      STDERR.puts( (fatal ? "Error: " : "Warning: ") + "#{whence} contains unknown member #{x}")
      exit(1) if fatal
    end
    return ok
  end
  def expand_groups
    @groups.each_pair do |groupname, group|
      group['members'].each do |member|
        check_exists(member, "Group #{groupname}")
      end
      group['members_to_do'] = group['members'].clone
    end

    while true
      had_progress = false
      all_expanded = true
      @groups.each_pair do |groupname, group|
        group['keys'] = [] unless group['keys'] 

        still_contains_groups = false
        group['members_to_do'].each do |member|
          if is_group(member)
            if @groups[member]['members_to_do'].size == 0
              group['keys'].concat @groups[member]['keys']
              group['members_to_do'].delete(member)
              had_progress = true
            else
              still_contains_groups = true
            end
          else
            group['keys'].push @users[member]
            group['members_to_do'].delete(member)
            had_progress = true
          end
        end
        all_expanded = false if still_contains_groups
      end
      break if all_expanded
      unless had_progress
        cyclic_groups = @groups.keys.reject{|name| @groups[name]['members_to_do'].size == 0}.join(", ")
        STDERR.puts "Cyclic group memberships in #{cyclic_groups}?"
        exit(1)
      end
    end
  end

  def expand_targets(targets)
    fprs = []
    ok = true
    targets.each do |t|
      unless check_exists(t, "access line", false)
        ok = false
        next
      end
      if is_group(t)
        fprs.concat @groups[t]['keys']
      else
        fprs.push @users[t]
      end
    end
    return ok, fprs
  end
end

class EncryptedFile
  attr_reader :accessible, :encrypted, :readable

  def EncryptedFile.determine_readable(readers)
    GnuPG.get_my_keys.each do |keyid|
      return true if readers.include?(keyid)
    end
    return false
  end

  def EncryptedFile.list_readers(statustxt)
    readers = []
    statustxt.split("\n").each do |line|
      m = /^\[GNUPG:\] ENC_TO ([0-9A-F]+)/.match line
      next unless m
      readers.push m[1]
    end
    return readers
  end

  def EncryptedFile.targets(text)
    metaline = text.split("\n").first
    m = /^access: (.*)/.match metaline
    return [] unless m
    return m[1].strip.split(/[\t ,]+/)
  end


  def initialize(filename)
    @groupconfig = GroupConfig.new

    @filename = filename
    unless FileTest.readable?(filename)
      @accessible = false
      return
    end
    @accessible = true
    @encrypted_content = File.read(filename)
    (outtxt, stderrtxt, statustxt) = GnuPG.gpgcall(@encrypted_content, %w{--with-colons --no-default-keyring --secret-keyring=/dev/null --keyring=/dev/null})
    @encrypted = !(statustxt =~ /\[GNUPG:\] NODATA/)
    if @encrypted
      @readers = EncryptedFile.list_readers(statustxt)
      @readable = EncryptedFile.determine_readable(@readers)
    end
  end

  def decrypt
    (outtxt, stderrtxt, statustxt, exitstatus) = GnuPG.gpgcall(@encrypted_content, %w{--decrypt})
    if exitstatus != 0
      proceed = read_input("Warning: gpg returned non-zero exit status #{exitstatus} when decrypting #{@filename}.  Proceed?")
      exit(0) unless proceed
    elsif outtxt.length == 0
      proceed = read_input("Warning: #{@filename} decrypted to an empty file.  Proceed?")
      exit(0) unless proceed
    end

    return outtxt
  end

  def encrypt(content, recipients)
    args = recipients.collect{ |r| "--recipient=#{r}"}
    args.push "--encrypt"
    (outtxt, stderrtxt, statustxt, exitstatus) = GnuPG.gpgcall(content, args)

    if exitstatus != 0
      proceed = read_input("Warning: gpg returned non-zero exit status #{exitstatus} when decrypting #{@filename}.  Proceed (or try again)?")
      return false unless proceed
    elsif outtxt.length == 0
      tryagain = read_input("Error: #{@filename} decrypted to an empty file.  Edit again (or exit)?")
      return false if tryagain
      exit(0)
    end

    return true, outtxt
  end


  def write_back(content)
    targets = EncryptedFile.targets(content)
    if targets.size == 0
      tryagain = read_input("Warning: Did not find targets to encrypt to in header.  Try again (or exit)?", true)
      return false if tryagain
      exit(0)
    end

    ok, expanded = @groupconfig.expand_targets(targets)
    if (expanded.size == 0)
      tryagain = read_input("Errors in access header.  Edit again (or exit)?", true)
      return false if tryagain
      exit(0)
    elsif (not ok)
      tryagain = read_input("Warnings in access header.  Edit again (or continue)?", true)
      return false if tryagain
    end

    ok, encrypted = encrypt(content, expanded)
    return false unless ok

    File.open(@filename,"w").write(encrypted)
    return true
  end
end

class Ls
  def help(parser, code=0, io=STDOUT)
    io.puts "Usage: #{$program_name} ls [<directory> ...]"
    io.puts parser.summarize
    io.puts "Lists the contents of the given directory/directories, or the current"
    io.puts "directory if none is given.  For each file show whether it is PGP-encrypted"
    io.puts "file, and if yes whether we can read it."
    exit(code)
  end

  def ls_dir(dirname)
    begin
      dir = Dir.open(dirname)
    rescue Exception => e
      STDERR.puts e
      return
    end
    puts "#{dirname}:"
    Dir.chdir(dirname) do
      dir.sort.each do |filename|
        next if (filename =~ /^\./) and not (@all >= 3)
        stat = File::Stat.new(filename)
        if stat.symlink?
          puts "(sym)      #{filename}" if (@all >= 2)
        elsif stat.directory?
          puts "(dir)      #{filename}" if (@all >= 2)
        elsif !stat.file?
          puts "(other)    #{filename}" if (@all >= 2)
        else
          f = EncryptedFile.new(filename)
          if !f.accessible
            puts "(!perm)    #{filename}"
          elsif !f.encrypted
            puts "(file)     #{filename}" if (@all >= 2)
          elsif f.readable
            puts "(ok)       #{filename}"
          else
            puts "(locked)   #{filename}" if (@all >= 1)
          end
        end
      end
    end
  end

  def initialize()
    @all = 0
    ARGV.options do |opts|
      opts.on_tail("-h", "--help" , "Display this help screen") { help(opts) }
      opts.on_tail("-a", "--all" , "Show all files (use up to 3 times to show even more than all)") { @all = @all+1 }
      opts.parse!
    end

    dirs = ARGV
    dirs.push('.') unless dirs.size > 0
    dirs.each { |dir| ls_dir(dir) }
  end
end

class Ed
  def help(parser, code=0, io=STDOUT)
    io.puts "Usage: #{$program_name} ed <filename>"
    io.puts parser.summarize
    io.puts "Decrypts the file, spawns an editor, and encrypts it again"
    exit(code)
  end

  def edit(filename)
    f = EncryptedFile.new(filename)
    if !f.readable && !@force
      STDERR.puts "#{filename} is probably not readable"
      exit(1)
    end

    content = f.decrypt
    while true
      oldsize = content.length
      tempfile = Tempfile.open('pws')
      tempfile.puts content
      tempfile.flush
      system($editor, tempfile.path)
      status = $?
      throw "Process has not exited!?" unless status.exited?
      unless status.exitstatus == 0
        proceed = read_input("Warning: Editor did not exit successfully (exit code #{status.exitstatus}.  Proceed?")
        exit(0) unless proceed
      end
      tempfile.seek(0, IO::SEEK_SET)
      content = tempfile.read

      # zero the file
      newsize = content.length
      tempfile.seek(0, IO::SEEK_SET)
      clearsize = (newsize > oldsize) ? newsize : oldsize
      tempfile.print "\0"*clearsize
      tempfile.fsync
      tempfile.close(true)

      if content.length == 0
        proceed = read_input("Warning: Content is now empty.  Proceed?")
        exit(0) unless proceed
      end

      success = f.write_back(content)
      break if success
    end
  end

  def initialize()
    ARGV.options do |opts|
      opts.on_tail("-h", "--help" , "Display this help screen") { help(opts) }
      opts.on_tail("-f", "--force" , "Spawn an editor even if the file is probably not readable") { |@force| }
      opts.parse!
    end
    help(ARGV.options, 1, STDERR) if ARGV.length != 1
    filename = ARGV.shift

    if !FileTest.exists?(filename)
      STDERR.puts "#{filename} does not exist"
      exit(1)
    elsif !FileTest.file?(filename)
      STDERR.puts "#{filename} is not a regular file"
      exit(1)
    elsif !FileTest.readable?(filename)
      STDERR.puts "#{filename} is not accessible (unix perms)"
      exit(1)
    end

    dirname = File.dirname(filename)
    basename = File.basename(filename)
    Dir.chdir(dirname) {
      edit(basename)
    }
  end
end


def help(code=0, io=STDOUT)
  io.puts "Usage: #{$program_name} ed"
  io.puts "       #{$program_name} ls"
  io.puts "       #{$program_name} help"
  io.puts "Call #{$program_name} <command> --help for additional options/parameters"
  exit(code)
end


def parse_command
  case ARGV.shift
    when 'ls': Ls.new
    when 'ed': Ed.new
    when 'help': 
      case ARGV.length
        when 0: help
        when 1:
          ARGV.push "--help"
          parse_command
        else help(1, STDERR)
      end
    else
      help(1, STDERR)
  end
end

parse_command

# vim:set shiftwidth=2:
# vim:set et:
# vim:set ts=2:
